# Emuladores y Depuradores para Sistemas Embebidos

---

## üì¶ Contenido

- [0. Introducci√≥n](#0-introducci√≥n)
- [1. Emuladores](#1-emuladores)
  - [1.1 QEMU](#11-qemu)
- [2. Depuradores](#2-depuradores)
  - [2.1 GDB (GNU Debugger)](#21-gdb-gnu-debugger)
  - [2.2 PDB (Python Debugger)](#22-pdb-python-debugger)
- [3. Demostraci√≥n pr√°ctica](#3-demostraci√≥n-pr√°ctica)
- [4. Tutorial](#4-tutorial)
- [6. Referencias](#5-referencias)

---

## 0. Introducci√≥n

Los sistemas embebidos est√°n presentes en una gran variedad de dispositivos, desde electrodom√©sticos hasta autom√≥viles y dispositivos m√©dicos. Sin embargo, desarrollar y depurar estos sistemas puede ser complejo debido a las limitaciones de hardware, las restricciones de recursos y la falta de acceso directo a plataformas f√≠sicas en etapas tempranas de desarrollo. 

Esta gu√≠a se centra en el uso de herramientas **open source** como emuladores y depuradores, las cuales permiten simular y depurar sistemas sin la necesidad de contar con hardware f√≠sico durante el proceso de desarrollo.

## Conceptos b√°sicos

###  Simulaci√≥n, emulaci√≥n y depuraci√≥n

| T√©rmino     | Descripci√≥n                                                                 |
|-------------|-----------------------------------------------------------------------------|
| Simulaci√≥n  | Ejecuta una representaci√≥n del sistema, sin correr binarios reales.         |
| Emulaci√≥n   | Ejecuta binarios como si estuvieran en el hardware objetivo (ej. QEMU).     |
| Depuraci√≥n  | Permite observar, controlar y modificar la ejecuci√≥n de c√≥digo en tiempo real.|


### ¬øQu√© se espera de una Simulaci√≥n y de una Emulaci√≥n?

| Tipo        | ¬øQu√© se espera?                                                                 | Ejemplo concreto                                                |
|-------------|----------------------------------------------------------------------------------|-----------------------------------------------------------------|
| **Simulaci√≥n** | Comportamiento l√≥gico o funcional del sistema, sin ejecutar el c√≥digo real.     | Simular un sensor de temperatura en MATLAB o un microcontrolador en SystemVerilog.          |
| **Emulaci√≥n**  | Ejecutar el binario tal como lo har√≠a el hardware real, con tiempos y entorno cercanos al f√≠sico. | Usar QEMU para correr una imagen de Linux ARM en tu PC o emular un microcontrolador STM32 para probar firmware.        |

### Diferencia clave:
- **Simulaci√≥n**: √∫til para **dise√±o y validaci√≥n temprana**.
- **Emulaci√≥n**: √∫til para **pruebas funcionales, depuraci√≥n y validaci√≥n sin hardware**.


## Modelos y pruebas avanzadas

- **Hardware-in-the-Loop (HIL)**: Pruebas con hardware real o parcialmente simulado.
  > Ejemplo: Probar un firmware en una placa real conectada a un modelo simulado de sensores.
- **Gemelo Digital (Digital Twin)**: R√©plica virtual del sistema f√≠sico usada para pruebas y validaciones.
  > Ejemplo: Un gemelo digital de un motor industrial permite ajustar par√°metros sin detener la producci√≥n.


## Pr√°cticas industriales 

| Tema                              | Relevancia                                                                 |
|-----------------------------------|----------------------------------------------------------------------------|
| Toolchains cruzadas               | Compilar/depurar desde PC para microcontroladores o sistemas embebidos objetivo. |
| Scripts de GDB (.gdbinit)         | Automatizar flujos repetitivos en debugging, ya sea hacerlos o usarlos.    |
| CI/CD con QEMU + GDB              | Pruebas de Integraci√≥n Continua y Despliegue Continuo de firmware sin hardware real.    |
| Interfaces JTAG/SWD               | Depuraci√≥n f√≠sica de microcontroladores (MCUs y SoCs).                     |
| Trazas (ej. Tracealyzer, ITM)     | An√°lisis de eventos y tiempos en RTOS o sistemas cr√≠ticos.                 |
| Breakpoints                       | Breakpoints en desarrollo, son puntos claves del codigo para analizar.     |
| Optimizaci√≥n vs Depuraci√≥n        | Uso de flags como `-Og` para depurar c√≥digo optimizado, es decur, saber c√≥mo las optimizaciones afectan la visibilidad del c√≥digo al depurar.|
| An√°lisis post-mortem (core dumps) | Inspecci√≥n de fallos ya ocurridos.                                        |


## 1. Emuladores

### 1.1 QEMU

<p align="center">
  <img src="images/Qemu_logo.png"  width="500"/>
</p>


QEMU (Quick Emulator) es un emulador y virtualizador de c√≥digo abierto, vers√°til y modular, que soporta m√∫ltiples arquitecturas como ARM, x86, MIPS y RISC-V. Se utiliza principalmente de dos maneras:

- **Emulaci√≥n de Sistema**: QEMU emula una m√°quina completa, permitiendo ejecutar un sistema operativo invitado. En este modo, la CPU puede ser completamente emulada o usar un hipervisor como KVM (Kernel-based Virtual Machine) para ejecutar directamente sobre el CPU del host. Este modo es ideal para testing  ya que permite emular sistemas completos sin necesidad de hardware real [1].

- **Emulaci√≥n en Modo Usuario**: QEMU permite ejecutar programas compilados para una arquitectura de CPU diferente en otra, emulando siempre la CPU.

Adem√°s, QEMU es compatible con **gdbserver** para depuraci√≥n remota, lo que facilita el desarrollo y la depuraci√≥n en entornos sin acceso inmediato a hardware f√≠sico. Adem√°s herramientas como **qemu-img** para crear y modificar im√°genes de disco.

<p align="center">
  <img src="images/Qemu_support.png"  width="1000"/>
</p>


üîó [Documentaci√≥n oficial de QEMU](https://www.qemu.org/docs/master/)  
üîó [Repositorio en GitLab](https://gitlab.com/qemu-project/qemu)

### Otros emuladores para explorar

- **Renode** ‚Äì Emulador especializado en sistemas embebidos con buses y sensores. Ideal para pruebas de RTOS y simulaciones deterministas.
- **Esp32-emulator** ‚Äì Para plataformas ESP32, √∫til en desarrollo de IoT.
- **SimAVR** ‚Äì Emulador para microcontroladores AVR, popular en el desarrollo de proyectos de electr√≥nica.
- **MSPDebug** ‚Äì Emulador y depurador para microcontroladores MSP430 de Texas Instruments.
- **PicSimLab / SimulIDE** ‚Äì Emuladores educativos para microcontroladores PIC y AVR, f√°ciles de usar para iniciarse en la programaci√≥n de microcontroladores.


## 2. Depuradores

### 2.1 GDB (GNU Debugger)

<p align="center">
  <img src="images/gdb_logo.png"  width="500"/>
</p>


GDB es el depurador est√°ndar para programas escritos en lenguajes como C, C++ , Assembler y otros, especialmente en entornos embebidos. Se utiliza para identificar y corregir errores en el c√≥digo, permitiendo a los desarrolladores analizar el comportamiento de sus programas en tiempo real [2]. Entre sus funciones permite:

- **Depuraci√≥n Remota**: GDB soporta depuraci√≥n remota, lo que permite depurar aplicaciones en sistemas que no tienen acceso directo al entorno de desarrollo, como dispositivos embebidos o m√°quinas virtuales.

- **Breakpoints y Seguimiento**: GDB permite establecer puntos de interrupci√≥n (breakpoints) para detener la ejecuci√≥n del programa en lugares espec√≠ficos, inspeccionar la memoria, los registros y el estado del programa en cualquier momento durante su ejecuci√≥n.

- **Conexi√≥n a Emuladores y Hardware Real**: GDB se puede conectar a emuladores como QEMU o a hardware real a trav√©s de herramientas como OpenOCD, lo que lo hace √∫til para trabajar en sistemas sin acceso directo al c√≥digo fuente o cuando se trabaja con plataformas de hardware especializadas.

üîó [Sitio oficial de GDB](https://www.sourceware.org/gdb/)  
üîó [Repositorio oficial](https://sourceware.org/git/binutils-gdb.git)


### 2.2 PDB (Python Debugger)

<p align="center">
  <img src="images/python_pdb_2.png"  width="300"/>
</p>


**PDB** es el depurador est√°ndar incluido en Python, utilizado para diagnosticar y comprender el comportamiento de un programa durante su ejecuci√≥n. Su funcionamiento se basa en una interfaz interactiva que permite examinar el estado interno del programa paso a paso [3].
PDB resulta especialmente √∫til para depurar scripts que interact√∫an con hardware, dispositivos perif√©ricos o procesos concurrentes. Dado que muchos entornos embebidos carecen de interfaces gr√°ficas, PDB proporciona una herramienta efectiva directamente desde la terminal [4].

Caracter√≠sticas principales:
- **Depuraci√≥n interactiva**: Permite detener la ejecuci√≥n en tiempo real, examinar variables, y avanzar instrucci√≥n por instrucci√≥n.
- **Puntos de interrupci√≥n (breakpoints)**: Se pueden establecer ubicaciones espec√≠ficas para pausar la ejecuci√≥n y observar el comportamiento del sistema.
- **An√°lisis post-mortem**: Posibilita revisar el estado del programa inmediatamente despu√©s de una excepci√≥n o fallo.
- **Integraci√≥n directa**: Se puede activar desde el c√≥digo fuente o ejecutar el script en modo depuraci√≥n desde la terminal.
- **Modularidad y personalizaci√≥n**: Al estar implementado como una clase (Pdb), se adapta a escenarios donde se requiera extender su funcionalidad para depuraci√≥n avanzada. 

üîó [Documentaci√≥n oficial](https://docs.python.org/3/library/pdb.html)  
üì¶ [C√≥digo fuente](https://github.com/python/cpython/blob/main/Lib/pdb.py)


### Otros depuradores para explorar

- **OpenOCD** ‚Äì Conexi√≥n entre GDB y hardware f√≠sico mediante JTAG/SWD. Compatible con diversas plataformas como ARM y RISC-V.
- **pyOCD** ‚Äì Depurador basado en Python para plataformas ARM Cortex-M, compatible con CMSIS-DAP.
- **SEGGER J-Link GDB Server** ‚Äì Herramienta muy utilizada en entornos industriales, ideal para depuraci√≥n en hardware real.
- **GDBserver** ‚Äì Usado para depuraci√≥n remota en sistemas Linux embebidos, trabajando junto con QEMU.
- **Tracealyzer** ‚Äì Herramienta de an√°lisis y depuraci√≥n para sistemas con RTOS, ideal para estudiar la ejecuci√≥n de software en plataformas embebidas.


## Casos de uso comunes de uso

| Escenario                        | Herramientas principales             |
|----------------------------------|--------------------------------------|
| MCU bare-metal                   | GDB + OpenOCD                        |
| Linux embebido                   | QEMU + GDB (gdbserver)               |
| RTOS sobre MCU                   | GDB                                  |
| CI/CD para firmware              | QEMU + GDB                           |
| Scripts Python en consola        | `pdb`                                |
| Aplicaciones Python medianas     | `pdb` + `breakpoint()`               |
| Pruebas automatizadas en Python  | `pytest` + `pdb`                     |
| Debug en notebooks interactivos  | `ipdb`, `%debug` (IPython/Jupyter)   |

---
## 3. Demostraci√≥n pr√°ctica

Esta demostraci√≥n busca guiar a trav√©s de un ejemplo pr√°ctico utilizando **QEMU + Python** para emular  un programa simple en un entorno embebido de Raspberry Pi OS Lite based on Debian12 (bookworm), pero en modo **shell root** directamente, sin pasar por **systemd**.
> **Nota**: `systemd` es un sistema de inicio y gesti√≥n de servicios en Linux.  
> Se encarga de arrancar todos los procesos del sistema (como redes, usuarios, etc.) despu√©s del kernel.  
> En este tutorial lo evitamos para entrar directamente a un **modo shell root minimalista**, ideal para pruebas r√°pidas, desarrollo embebido y debugging sin interferencias.

## Parte I: Emulaci√≥n de Raspberry Pi OS Lite con QEMU en Modo Shell Root
### ‚úÖ Prerequisitos

- Ubuntu Linux (20.04 o superior)
- Git
- QEMU instalado (Se instalan en esta gu√≠a y en el tutorial)
- Imagen `.img` de Raspberry Pi OS Lite ( `2024-11-19-raspios-bookworm-armhf-lite.img`, se instala en esta gu√≠a)
- Kernel compatible para QEMU ( `kernel-qemu-4.19.50-buster`, ya includo en el repositorio)
- Archivo `.dtb` compatible (`versatile-pb.dtb`, ya includo en el repositorio)


### üõ†Ô∏è Hardware por Emular (Target)
La siguiente tabla describe el hardware virtual que se emular√° con QEMU para correr una imagen ligera de Raspberry Pi OS en un entorno completamente controlado:

| Componente          | Descripci√≥n del Componente Emulado                                                                                                    |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| üß† `-cpu arm1176`   | Procesador **ARM1176JZF-S**, el mismo que utiliza la Raspberry Pi modelo 1. Soporta ARMv6 con MMU (gesti√≥n de memoria) y FPU.         |
| üíæ `-m 256`         | Memoria RAM de **256 MB**                                     |
| üì¶ `-M versatilepb` | Placa base virtual **Versatile Platform Baseboard**  |
| üìÄ `-hda`           | Disco duro virtual que contiene la imagen del sistema operativo: **Raspberry Pi OS Lite basado en Debian 12 (Bookworm)**.             |
| üß¨ `-dtb`           | **Device Tree Blob** que informa al sistema operativo de las caracter√≠sticas del hardware virtual (`versatile-pb.dtb`).               |
| üêß `-kernel`        | Kernel Linux precompilado, ajustado para funcionar sobre la arquitectura y perif√©ricos del sistema emulado (no usa el kernel de RPi). |
| üî° `-serial stdio`  | Redirecci√≥n del **puerto serie** a la terminal de la m√°quina host, permitiendo interacci√≥n por consola con el sistema emulado.        |
| üîß `-append`        | Par√°metros de arranque: monta `/dev/sda2` como sistema ra√≠z, usa `ext4`, y lanza directamente el **shell** (`/bin/sh`) sin `systemd`. |
| üîÅ `-no-reboot`     | Previene reinicios autom√°ticos tras errores, ideal para tareas de depuraci√≥n o an√°lisis de bajo nivel.                                |
                                 



### Paso 1: Desde una terminal se deben instalar los siguientes paquetes:
```bash
sudo apt update
sudo apt install qemu-system-arm
sudo apt install qemu-utils
sudo apt install qemu-efi
```
### Paso 2: Clonar el Repositorio `emulators-debuggers-class`.
El repositorio completo contiene la siguiente estructura: 
```
emulators-debuggers-class/
  ‚îú‚îÄ‚îÄ diagnostic/
  ‚îÇ   ‚îú‚îÄ‚îÄ arbol
  ‚îÇ   ‚îú‚îÄ‚îÄ arbol.cpp
  ‚îÇ   ‚îî‚îÄ‚îÄ solucion/
  ‚îú‚îÄ‚îÄ images/
  ‚îú‚îÄ‚îÄ demo/
  ‚îÇ   ‚îú‚îÄ‚îÄ pdb/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pyfetch.py
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pyfetch_2_0.py
  ‚îÇ   ‚îî‚îÄ‚îÄ qemu/
  ‚îÇ       ‚îú‚îÄ‚îÄ run-qemu.sh
  ‚îÇ       ‚îî‚îÄ‚îÄ qemu-rpi/
  ‚îÇ           ‚îú‚îÄ‚îÄ kernel-qemu-4.19.50-buster
  ‚îÇ           ‚îî‚îÄ‚îÄ versatile-pb.dtb
  ‚îî‚îÄ‚îÄ tutorial/
        ‚îú‚îÄ‚îÄ practica_bonus_asm
        ‚îî‚îÄ‚îÄ qemu 
              ‚îú‚îÄ‚îÄ run-qemu.sh
              ‚îî‚îÄ‚îÄ qemu-rpi/
                     ‚îú‚îÄ‚îÄ kernel-qemu-4.19.50-buster
                     ‚îî‚îÄ‚îÄ versatile-pb.dtb
```

A nivel de la demostraci√≥n, nos vamos a enfocar en el directorio `demo`. 

```
emulators-debuggers-class/
  ‚îú‚îÄ‚îÄ demo/
     ‚îú‚îÄ‚îÄ pdb/
     ‚îÇ   ‚îú‚îÄ‚îÄ pyfetch.py
     ‚îÇ   ‚îî‚îÄ‚îÄ pyfetch_2_0.py
     ‚îî‚îÄ‚îÄ qemu/
         ‚îú‚îÄ‚îÄ run-qemu.sh
         ‚îî‚îÄ‚îÄ qemu-rpi/
             ‚îú‚îÄ‚îÄ kernel-qemu-4.19.50-buster
              ‚îî‚îÄ‚îÄ versatile-pb.dtb
```

## Paso 3: Instalar la imagen de Raspberry Pi OS Lite

Para poder emular el sistema operativo de Raspberry Pi, es necesario descargar la imagen del sistema. Esta puede obtenerse desde la p√°gina oficial de Raspberry Pi. La versi√≥n m√°s reciente al momento de esta gu√≠a es: `2024-11-19-raspios-bookworm-armhf-lite.img`.
Alternativamente, se puede descargar de manera manual en la pagina oficial de `Raspberry Pi` dentro del directorio `emulators-debuggers-class/demo/qemu` o mediante una terminal. 

üîó [Descargar desde la p√°gina oficial](https://downloads.raspberrypi.org/raspios_lite_armhf/images/raspios_lite_armhf-2024-11-19/)

<p align="center">
  <img src="images/rasbian_lite_instalar.png"  width="800"/>
</p>

üîó Mediante una terminal 

Se debe ingresar dentro del directorio demo/qemu
```bash
cd ~/emulators-debuggers-class/demo/qemu
```

Luego instalar y descomprimir la imagen (puede tardar un poco, dependiendo de la conexion de internet)

Para instalar:
```bash
wget https://downloads.raspberrypi.com/raspios_lite_armhf/images/raspios_lite_armhf-2024-11-19/2024-11-19-raspios-bookworm-armhf-lite.img.xz
```
Para descomprimir: 
```bash
xz -dk 2024-11-19-raspios-bookworm-armhf-lite.img.xz
```

## Paso 4: Verificar instalaciones antes de la emulaci√≥n

Para este punto dentro del directorio `emulators-debuggers-class/demo/qemu` deber√≠a contener:

```plaintext
total 2249372
1729296 -rw-r--r-- 1 laptop laptop 8589934592  2024-11-19-raspios-bookworm-armhf-lite.img
 520068 -rw-r--r-- 1 laptop laptop  532543404  2024-11-19-raspios-bookworm-armhf-lite.img.xz
      4 drwxr-xr-x 2 laptop laptop       4096  qemu-rpi
      4 -rwxr-xr-x 1 laptop laptop        309  run-qemu.sh
```

Se puede verificar mediante este comando:

```bash
ls -ls ~/emulators-debuggers-class/demo/qemu
```

Otro aspecto **importante** que se debe ver es el contenido de `run-qemu.sh`, este contiene toda la configuraci√≥n necesaria para emular el sistema Raspberry OS Lite con Qemu.

Al hacer `cat` a `run-qemu.sh` dentro del directorio `~/emulators-debuggers-class/demo/qemu`

```bash
cat run-qemu.sh
```
se despliega su contenido por respuesta:

```plaintext
qemu-system-arm \
  -kernel qemu-rpi/kernel-qemu-4.19.50-buster \
  -cpu arm1176 \
  -m 256 \
  -M versatilepb \
  -dtb qemu-rpi/versatile-pb.dtb \
  -no-reboot \
  -serial stdio \
  -append "root=/dev/sda2 rootfstype=ext4 rw console=ttyAMA0 init=/bin/sh"  \
  -hda 2024-11-19-raspios-bookworm-armhf-lite.img
```
Estos par√°metros tienen un significado que configuran al dispositivo a emular.

| Par√°metro        | Descripci√≥n                                                                                                                                            |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `-kernel`        | Kernel Linux compilado para QEMU y compatible con Raspberry Pi.                                                                                        |
| `-cpu arm1176`   | Emula la CPU ARMv6 usada en las primeras Raspberry Pi.                                                                                                 |
| `-m 256`         | Asigna 256 MB de memoria RAM al sistema emulado.                                                                                                       |
| `-M versatilepb` | Emula la placa base VersatilePB, compatible con el kernel proporcionado.                                                                               |
| `-dtb`           | Archivo Device Tree (`.dtb`) necesario para describir el hardware virtualizado.                                                                        |
| `-no-reboot`     | Impide que QEMU reinicie autom√°ticamente tras un apagado.                                                                                              |
| `-serial stdio`  | Redirige la consola serial al terminal para poder interactuar con el sistema.                                                                          |
| `-append`        | Par√°metros pasados al kernel: define la ra√≠z del sistema, el tipo de sistema de archivos, la consola, y arranca directamente en una shell (`/bin/sh`). |
| `-hda`           | Imagen del sistema Raspberry Pi OS Lite que se monta como disco principal.                                                                             |


>**Nota**: La imagen utilizada (2024-11-19-raspios-bookworm-armhf-lite.img) en este entorno inicia en modo shell (init=/bin/sh), √∫til para debugging o configuraciones avanzadas. Para arrancar el sistema completo, puedes cambiar esa l√≠nea por:
>
>```plaintext
>append "root=/dev/sda2 rootfstype=ext4 rw console=ttyAMA0"
>```





## Paso 5: A emular

Primero se le deben dar permisos al ejecutable `run-qemu.sh`.

```bash
chmod +x run-qemu.sh
```
A emular:

```bash
./run-qemu.sh
```
Se deber√≠a desplegar una ventana como esta,



<p align="center">
  <img src="images/emular_rasp.png"  width="800"/>
</p>

Pero lo importante est√° en la terminal, esta versi√≥n de Raspberry OS no cuenta con interfaz gr√°fica, pero si con Python, G++ y GDB integrados.

### ‚úÖ Paso 5.1: Interactuar con el sistema
En este momento, al estar dentro del sistema `Raspberry` OS Lite se puede interactuar de manera b√°sica con el sistema de la siguiente manera: 

- Ver directorios de root.

```bash
ls /
```
- Ver informaci√≥n sobre la distribuci√≥n de Linux utilizada:
  
```bash
cat /etc/os-release
```
- Ver toda la informaci√≥n disponible del kernel del sistema.
```bash
uname -a
```
- Ver la versi√≥n de Python, as (GNU Binutils for Raspbian) y GDB.

```bash
python3 --version; as --version; gdb --version
```
---

# üîß Parte II: Programar y Depurar dentro de la Emulaci√≥n con Python y PDB

### Paso 6: Familiarizarse con las herramientas de depuraci√≥n
Para esta secci√≥n, requerimos de 4 herramientas:
- Un editor de texto, en este caso se utilizar√° `vi` (Ya inclu√≠do en la imagen).
- El c√≥digo a depurar. (Se incluye m√°s adelante)
- El int√©rprete de Python (Ya inclu√≠do en la imagen)
- El depurador PDB (Ya inclu√≠do en la imagen).


### üß≠ Paso 6.1: Uso de `vi` como editor de texto

Al no tener interfaz gr√°fica, se trabaja con editores en terminal. Uno de los m√°s comunes es `vi`, un editor poderoso y presente por defecto en la mayor√≠a de sistemas UNIX/Linux.

#### Modo de uso

`vi` trabaja con **dos modos** principales:
- **Normal**: para comandos (volver con `ESC`)
- **Inserci√≥n**: para escribir texto (`i`, `a`, `o`, etc.)

###  Comandos esenciales de `vi`

| Categor√≠a | Comando | Descripci√≥n |
|----------|---------|-------------|
| **Insertar** | `i` / `I` | Insertar antes / al inicio de l√≠nea |
|              | `a` / `A` | Insertar despu√©s / al final de l√≠nea |
|              | `o` / `O` | Nueva l√≠nea debajo / encima |
|              | `ESC`     | Volver al modo normal |
| **Guardar / Salir** | `:w` / `:q` | Guardar / salir |
|                    | `:wq`       | Guardar y salir |
|                    | `:q!`       | Salir sin guardar |
|                    | `ZZ`        | Guardar y salir (modo normal) |
| **Movimiento** | `h` `j` `k` `l` | Izquierda / abajo / arriba / derecha |
|                | `0` / `^` / `$` | Inicio / 1er car√°cter / final de l√≠nea |
|                | `gg` / `G` / `:n` | Inicio / fin / ir a l√≠nea `n` |
| **Edici√≥n** | `x` / `dd` / `yy` | Borrar car√°cter / borrar l√≠nea / copiar l√≠nea |
|             | `p` / `P`         | Pegar debajo / encima |
|             | `u` / `Ctrl+r`    | Deshacer / rehacer |
| **Buscar** | `/texto` / `?texto` | Buscar hacia abajo / arriba |
|            | `n` / `N`         | Siguiente / anterior coincidencia |
| **Otros** | `:set number` / `:set nonumber` | Mostrar / ocultar n√∫meros de l√≠nea |
|           | `:syntax on` / `:syntax off`   | Activar / desactivar resaltado |

Para empezar a editar un archivo desde la terminal:
```bash
vi archivo.py
```
Despliega en esta caso, el programa (En este caso se creo un "Hola mundo") :

<p align="center">
  <img src="images/vi_hola_py.png"  width="500"/>
</p>


### üìÄ Paso 6.2: C√≥digo a Depurar 

El siguiente script es una utilidad ligera escrita en Python que muestra informaci√≥n b√°sica del sistema al estilo de Neofetch, una herramienta popular en Linux para mostrar datos del sistema de forma visual y est√©tica en la terminal.
 
> **Nota:** **Neofetch** es una herramienta de l√≠nea de comandos escrita en **Bash** que muestra informaci√≥n del sistema de forma visual y personalizable.  
>
> Se puede instalar con:
>
> ```bash
> sudo apt install neofetch
> ```
> 
> Se puede ejecutar:
>
> ```bash
> neofetch
> ```



**El codigo por depurar es el siguente**:

En la terminal de  Qemu, se debe acceder al directorio `home/pi` de esta manera `cd home/pi`. Luego se debe ejecutar, lo siguiente (Este es el c√≥digo a depurar).  
```bash
echo "!/usr/bin/env python3\nimport platform\nimport os\nimport time\n\n# Obtener informaci√≥n del sistema\n\ndef system_info():\n    # Intentar obtener el tiempo de actividad\n    try:\n        with open('/proc/uptime', 'r') as f:\n            uptime_seconds = float(f.readline().split()[0])\n    except FileNotFoundError:\n        uptime_seconds = 0\n    uptime_hours = int(uptime_seconds / 3600)\n    uptime_minutes = int((uptime_seconds % 3600) / 60)\n    uptime_seconds_final = int(uptime_seconds % 60)\n\n    # Intentar obtener la memoria total\n    try:\n        with open('/proc/meminfo', 'r') as f:\n            lines = f.readlines()\n        mem_total = int(lines[0].split()[1]) // 1024  # Convertir de KB a MB\n        mem_total_gb = round(mem_total / 1024, 2)  # Convertir de MB a GB\n    except FileNotFoundError:\n        mem_total = 'Desconocido'\n        mem_total_gb = 'Desconocido'\n    except Exception as e:\n        mem_total = 'Error: ' + str(e)\n        mem_total_gb = 'Error'\n\n    # Intentar obtener el nombre del host\n    host_name = platform.node() or 'Desconocido'\n\n    # Intentar obtener el sistema operativo y su versi√≥n\n    try:\n        with open('/etc/os-release', 'r') as f:\n            os_info = f.read().splitlines()\n        os_name = [line for line in os_info if 'PRETTY_NAME' in line][0].split('=')[1].strip('\"')\n    except FileNotFoundError:\n        os_name = 'Desconocido'\n\n    # Intentar obtener la shell usada\n    try:\n        shell = os.environ.get('SHELL', 'Desconocido')\n    except Exception:\n        shell = 'Desconocido'\n\n    # Intentar obtener paquetes instalados\n    try:\n        with open('/var/lib/dpkg/status', 'r') as f:\n            package_count = sum(1 for line in f if line.startswith('Package:'))\n    except FileNotFoundError:\n        package_count = 'Desconocido'\n\n    # Obtener la versi√≥n del kernel\n    kernel_version = os.popen('uname -r').read().strip()\n\n    # Obtener informaci√≥n de la CPU\n    try:\n        cpu_info = os.popen('dmesg | grep -i \"cpu\"').read\n    except Exception:\n        cpu_info = 'Error al obtener informaci√≥n de la CPU'\n\n    # Obtener detalles de RAM desde dmesg\n    try:\n        ram_info = os.popen('dmesg | grep -i \"memory\"').read\n    except Exception:\n        ram_info = 'Error al obtener informaci√≥n de RAM'\n\n    # Imprimir la informaci√≥n del sistema\n    print('\\033[93m---------------------GENERAL INFORMATION---------------------\\033[0m')\n    print(f'Sistema Operativo : {os_name}')\n    print(f'Versi√≥n del kernel: {kernel_version}')\n    print(f'Arquitectura      : {platform.machine()}')\n    print(f'Tiempo encendido  : {uptime_hours} horas, {uptime_minutes} minutos, {uptime_seconds_final} segundos')\n    print(f'RAM Total         : {mem_total_gb} GB' if mem_total != 'Desconocido' else 'RAM Total: Desconocido')\n    print(f'Nombre del host   : {host_name}')\n    print(f'Shell             : {shell}')\n    print(f'Paquetes instalados: {package_count}')\n\n    # Imprimir informaci√≥n separada sobre la CPU\n    print('\\033[93m' + '-' * 20 + ' CPU INFORMATION ' + '-' * 20 + '\\033[0m')\n    print(cpu_info)\n\n    # Imprimir informaci√≥n separada sobre la RAM\n    print('\\033[93m' + '-' * 20 + ' MEMORY INFORMATION ' + '-' * 20 + '\\033[0m')\n    print(ram_info)\n\nif __name__ == '__main__':\n    oos.system('clear')  # En Windows ser√≠a 'cls'\n    system_info()" > /home/pi/pyfetch.py
```
> A este punto se debe haber creado el script llamado `pyfetch.py`, se puede verificar haciendo un  `ls` en la terminal.

### Paso 6.3: Depuraci√≥n
El script llamado `pyfetch.py`, presenta una serie de errores, que deben ser corregidos para desplegar la informaci√≥n del sistema de manera correcta, esto se realizar√° mediante el uso del depurador PDB integra de manera nativa en Python. El objetivo del script es desplegar lo siguiente: 

<p align="center">
  <img src="images/pyfetch.png"  width="800"/>
</p>

### üõ† Comandos √∫tiles dentro de pdb

| Comando           | Significado                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| `n`               | Ejecuta la siguiente l√≠nea (sin entrar a funciones)                    |
| `s`               | Entra a la funci√≥n en la l√≠nea actual (*step into*)                    |
| `c`               | Continua la ejecuci√≥n hasta el siguiente *breakpoint*                  |
| `q`               | Sale del depurador (*quit*)                                            |
| `p var`           | Imprime el valor de una variable (`p x`)                               |
| `l`               | Lista el c√≥digo fuente alrededor de la l√≠nea actual                    |
| `b l√≠nea`         | Establece un *breakpoint* en la l√≠nea indicada (`b 42`)                |
| `b archivo:l√≠nea` | Establece un *breakpoint* en un archivo espec√≠fico (`b pyfetch.py:30`) |
| `cl n√∫mero`       | Elimina un *breakpoint* (`cl 1`)                                       |
| `disable n√∫mero`  | Desactiva temporalmente un *breakpoint* (`disable 1`)                  |
| `enable n√∫mero`   | Reactiva un *breakpoint* desactivado (`enable 1`)                      |
| `where` / `w`     | Muestra el *call stack* (rastro de llamadas)                           |
| `args`            | Muestra los argumentos de la funci√≥n actual                            |
| `retval`          | Muestra el valor devuelto por la √∫ltima funci√≥n al salir de ella       |
| `! expr`          | Ejecuta una expresi√≥n Python arbitraria (por ejemplo, `!x.append(1)`)  |
| `help`            | Muestra ayuda general o de un comando espec√≠fico (`help p`)            |

---
Para depurar se deben aplicar las siguientes banderas:
```bash
python3 -m pdb pyfetch.py
```

- Reto a: ERROR 1 (¬øSE COMENTA O NO?)
 
- Reto b: ERROR 2 (¬øLa biblioteca est√° correctamente usada?)

- Reto c: ERROR 3 (¬øY mis datos de CPU?)

- Reto d: ERROR 4 (¬øY mis datos de RAM?))



---
## 4. Tutorial

Este tutorial proporciona una gu√≠a paso a paso para emular un programa simple en un entorno embebido utilizando **QEMU + AS + GDB**, ejecutando directamente en **modo shell root** sobre una imagen de **Raspberry Pi OS Lite basada en Debian 12 (Bookworm)**, sin pasar por `systemd`.

> üéØ **Objetivo final**: Ejecutar un entorno shell funcional en QEMU y poder compilar/programar con herramientas embebidas.

---

### ‚úÖ Prerrequisitos

Aseg√∫rate de contar con lo siguiente:

- Ubuntu Linux 20.04 o superior
- Herramientas necesarias instaladas (se detallan a continuaci√≥n)
- Imagen `.img` de Raspberry Pi OS Lite  
  `2024-11-19-raspios-bookworm-armhf-lite.img`
- Kernel compatible para QEMU `kernel-qemu-4.19.50-buster` (ya incluido)
- √Årbol de dispositivos `.dtb` compatible `versatile-pb.dtb` (ya incluido)

> üìù **Nota importante**: Para el documento a entregar, **toma una captura de pantalla** al finalizar cada paso y col√≥cala en el documento de plantilla adjunto.
> Recomendaci√≥n: Revisar la plantilla para conocer que pasos requieren de captura de pantalla.

---

### üõ†Ô∏è Hardware por Emular (Target)
La siguiente tabla describe el hardware virtual que se emular√° con QEMU para correr una imagen ligera de Raspberry Pi OS en un entorno completamente controlado:

| Componente          | Descripci√≥n del Componente Emulado                                                                                                    |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| üß† `-cpu arm1176`   | Procesador **ARM1176JZF-S**, el mismo que utiliza la Raspberry Pi modelo 1. Soporta ARMv6 con MMU (gesti√≥n de memoria) y FPU.         |
| üíæ `-m 256`         | Memoria RAM de **256 MB**, suficiente para sistemas embebidos ligeros como Raspberry Pi OS Lite.                                      |
| üì¶ `-M versatilepb` | Placa base virtual **Versatile Platform Baseboard**, una plataforma de referencia ampliamente soportada por QEMU para entornos ARM.   |
| üìÄ `-hda`           | Disco duro virtual que contiene la imagen del sistema operativo: **Raspberry Pi OS Lite basado en Debian 12 (Bookworm)**.             |
| üß¨ `-dtb`           | **Device Tree Blob** que informa al sistema operativo de las caracter√≠sticas del hardware virtual (`versatile-pb.dtb`).               |
| üêß `-kernel`        | Kernel Linux precompilado, ajustado para funcionar sobre la arquitectura y perif√©ricos del sistema emulado (no usa el kernel de RPi). |
| üî° `-serial stdio`  | Redirecci√≥n del **puerto serie** a la terminal de la m√°quina host, permitiendo interacci√≥n por consola con el sistema emulado.        |
| üîß `-append`        | Par√°metros de arranque: monta `/dev/sda2` como sistema ra√≠z, usa `ext4`, y lanza directamente el **shell** (`/bin/sh`) sin `systemd`. |
| üîÅ `-no-reboot`     | Previene reinicios autom√°ticos tras errores, ideal para tareas de depuraci√≥n o an√°lisis de bajo nivel.                                |
                                 




### üîß Paso 1: Instalar herramientas necesarias

Desde una terminal, ejecuta los siguientes comandos:

```bash
sudo apt update
sudo apt install qemu-system-arm qemu-efi
```

### Paso 2: Clonar el Repositorio `emulators-debuggers-class`.
El repositorio completo contiene la siguiente estructura: 
```
emulators-debuggers-class/
  ‚îú‚îÄ‚îÄ diagnostic/
  ‚îÇ   ‚îú‚îÄ‚îÄ arbol
  ‚îÇ   ‚îú‚îÄ‚îÄ arbol.cpp
  ‚îÇ   ‚îî‚îÄ‚îÄ solucion/
  ‚îú‚îÄ‚îÄ images/
  ‚îú‚îÄ‚îÄ demo/
  ‚îÇ   ‚îú‚îÄ‚îÄ pdb/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pyfetch.py
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pyfetch_2_0.py
  ‚îÇ   ‚îî‚îÄ‚îÄ qemu/
  ‚îÇ       ‚îú‚îÄ‚îÄ run-qemu.sh
  ‚îÇ       ‚îî‚îÄ‚îÄ qemu-rpi/
  ‚îÇ           ‚îú‚îÄ‚îÄ kernel-qemu-4.19.50-buster
  ‚îÇ           ‚îî‚îÄ‚îÄ versatile-pb.dtb
  ‚îî‚îÄ‚îÄ tutorial/
        ‚îú‚îÄ‚îÄ practica_c_gdb
        ‚îú‚îÄ‚îÄ practica_bonus_asm
        ‚îú‚îÄ‚îÄ plantilla_tutorial
        ‚îî‚îÄ‚îÄ practica_qemu 
              ‚îú‚îÄ‚îÄ run-qemu.sh
              ‚îî‚îÄ‚îÄ qemu-rpi/
                     ‚îú‚îÄ‚îÄ kernel-qemu-4.19.50-buster
                     ‚îî‚îÄ‚îÄ versatile-pb.dtb
```

A nivel de este tutorial gu√≠a, nos vamos a enfocar en el directorio `tutorial`. 

```
emulators-debuggers-class/
  ‚îú‚îÄ‚îÄ tutorial/
        ‚îú‚îÄ‚îÄ practica_c_gdb
        ‚îú‚îÄ‚îÄ plantilla_tutorial
        ‚îú‚îÄ‚îÄ practica_bonus_asm
        ‚îî‚îÄ‚îÄ practica_qemu 
              ‚îú‚îÄ‚îÄ run-qemu.sh
              ‚îî‚îÄ‚îÄ qemu-rpi/
                     ‚îú‚îÄ‚îÄ kernel-qemu-4.19.50-buster
                     ‚îî‚îÄ‚îÄ versatile-pb.dtb
```

## Paso 3: Instalar la imagen de Raspberry Pi OS Lite

Para poder emular el sistema operativo de Raspberry Pi, es necesario descargar la imagen del sistema. Esta puede obtenerse desde la p√°gina oficial de Raspberry Pi. La versi√≥n m√°s reciente al momento de esta gu√≠a es: `2024-11-19-raspios-bookworm-armhf-lite.img`.
Alternativamente, se puede descargar de manera manual en la pagina oficial de `Raspberry Pi` dentro del directorio `emulators-debuggers-class/tutorial/qemu` o mediante una terminal. 

üîó [Descargar desde la p√°gina oficial](https://www.raspberrypi.com/software/operating-systems/)

<p align="center">
  <img src="images/rasbian_lite_instalar.png"  width="800"/>
</p>

üîó Mediante una terminal 

Se debe ingresar dentro del directorio `tutorial/qemu`
```bash
cd ~/emulators-debuggers-class/tutorial/qemu
```

Luego instalar y descomprimir la imagen (puede tardar un poco, dependiendo de la conexion de internet)
```bash
wget https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2024-11-19/2024-11-19-raspios-bookworm-arm64-lite.img.xz
xz -dk 2024-11-19-raspios-bookworm-arm64-lite.img.xz
```

## Paso 4: Verificar instalaciones antes de la emulaci√≥n

Para este punto dentro del directorio `emulators-debuggers-class/tutorial/qemu` deber√≠a contener:

```plaintext
total 2249372
1729296 -rw-r--r-- 1 laptop laptop 8589934592  2024-11-19-raspios-bookworm-armhf-lite.img
 520068 -rw-r--r-- 1 laptop laptop  532543404  2024-11-19-raspios-bookworm-armhf-lite.img.xz
      4 drwxr-xr-x 2 laptop laptop       4096  qemu-rpi
      4 -rwxr-xr-x 1 laptop laptop        309  run-qemu.sh
```

Se puede verificar mediante este comando:

```bash
ls -ls ~/emulators-debuggers-class/tutorial/qemu
```

Otro aspecto **importante** que se debe ver es el contenido de `run-qemu.sh`, este contiene toda la configuraci√≥n necesaria para emular el sistema Raspberry OS Lite con Qemu.

Al hacer `cat` a `run-qemu.sh` dentro del directorio `~/emulators-debuggers-class/tutorial/qemu`

```bash
cat run-qemu.sh
```
se despliega su contenido por respuesta:

```plaintext
qemu-system-arm \
  -kernel qemu-rpi/kernel-qemu-4.19.50-buster \
  -cpu arm1176 \
  -m 256 \
  -M versatilepb \
  -dtb qemu-rpi/versatile-pb.dtb \
  -no-reboot \
  -serial stdio \
  -append "root=/dev/sda2 rootfstype=ext4 rw console=ttyAMA0 init=/bin/sh"  \
  -hda 2024-11-19-raspios-bookworm-armhf-lite.img
```
Estos par√°metros tienen un significado que configuran al dispositivo a emular.

| Par√°metro        | Descripci√≥n                                                                                                                                            |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `-kernel`        | Kernel Linux compilado para QEMU y compatible con Raspberry Pi.                                                                                        |
| `-cpu arm1176`   | Emula la CPU ARMv6 usada en las primeras Raspberry Pi.                                                                                                 |
| `-m 256`         | Asigna 256 MB de memoria RAM al sistema emulado.                                                                                                       |
| `-M versatilepb` | Emula la placa base VersatilePB, compatible con el kernel proporcionado.                                                                               |
| `-dtb`           | Archivo Device Tree (`.dtb`) necesario para describir el hardware virtualizado.                                                                        |
| `-no-reboot`     | Impide que QEMU reinicie autom√°ticamente tras un apagado.                                                                                              |
| `-serial stdio`  | Redirige la consola serial al terminal para poder interactuar con el sistema.                                                                          |
| `-append`        | Par√°metros pasados al kernel: define la ra√≠z del sistema, el tipo de sistema de archivos, la consola, y arranca directamente en una shell (`/bin/sh`). |
| `-hda`           | Imagen del sistema Raspberry Pi OS Lite que se monta como disco principal.                                                                             |

## Paso 5: A emular

Primero se le deben dar permisos al ejecutable `run-qemu.sh`.

```bash
chmod +x run-qemu.sh
```
A emular:

```bash
./run-qemu.sh
```
Se deber√≠a desplegar una ventana como esta,

<p align="center">
  <img src="images/emular_rasp.png"  width="800"/>
</p>

Pero lo importante est√° en la terminal, esta versi√≥n de Raspberry OS no cuenta con interfaz gr√°fica, pero si con Python, G++ y GDB integrados. 

### ‚úÖ Paso 5.1: Interactuar con el sistema
En este momento, al estar dentro del sistema `Raspberry OS Lite` se puede interactuar de manera b√°sica con el sistema de la siguiente manera: 

- Ver directorios de root.

```bash
ls /
```
- Ver informaci√≥n sobre la distribuci√≥n de Linux utilizada:
  
```bash
cat /etc/os-release
```
- Ver toda la informaci√≥n disponible del kernel del sistema.
```bash
uname -a
```

- Ver la versi√≥n de Python, as y GDB.
```bash
python3 --version; as --version; gdb --version
```

- **NUEVO:** Ver el registro de arranque del sistema.
```bash
dmesg
```


# üîß Parte II: Programar y Depurar en Ensamblador con `as` y GDB

### Paso 6: Familiarizarse con las herramientas de depuraci√≥n
Para esta secci√≥n, requerimos de 4 herramientas:
- Un editor de texto, en este caso se utilizar√° `vi` (Ya incluido en la imagen).
- El c√≥digo a depurar (se incluye m√°s adelante).
- El ensamblador `as` (Ya incluido en la imagen).
- El depurador GDB (Ya incluido en la imagen).


### üß≠ Paso 6.1: Uso de `vi` como editor de texto

Al no tener interfaz gr√°fica, se trabaja con editores en terminal. Uno de los m√°s comunes es `vi`, un editor poderoso y presente por defecto en la mayor√≠a de sistemas UNIX/Linux.

#### Modo de uso

`vi` trabaja con **dos modos** principales:
- **Normal**: para comandos (volver con `ESC`)
- **Inserci√≥n**: para escribir texto (`i`, `a`, `o`, etc.)

###  Comandos esenciales de `vi`

| Categor√≠a | Comando | Descripci√≥n |
|----------|---------|-------------|
| **Insertar** | `i` / `I` | Insertar antes / al inicio de l√≠nea |
|              | `a` / `A` | Insertar despu√©s / al final de l√≠nea |
|              | `o` / `O` | Nueva l√≠nea debajo / encima |
|              | `ESC`     | Volver al modo normal |
| **Guardar / Salir** | `:w` / `:q` | Guardar / salir |
|                    | `:wq`       | Guardar y salir |
|                    | `:q!`       | Salir sin guardar |
|                    | `ZZ`        | Guardar y salir (modo normal) |
| **Movimiento** | `h` `j` `k` `l` | Izquierda / abajo / arriba / derecha |
|                | `0` / `^` / `$` | Inicio / 1er car√°cter / final de l√≠nea |
|                | `gg` / `G` / `:n` | Inicio / fin / ir a l√≠nea `n` |
| **Edici√≥n** | `x` / `dd` / `yy` | Borrar car√°cter / borrar l√≠nea / copiar l√≠nea |
|             | `p` / `P`         | Pegar debajo / encima |
|             | `u` / `Ctrl+r`    | Deshacer / rehacer |
| **Buscar** | `/texto` / `?texto` | Buscar hacia abajo / arriba |
|            | `n` / `N`         | Siguiente / anterior coincidencia |
| **Otros** | `:set number` / `:set nonumber` | Mostrar / ocultar n√∫meros de l√≠nea |
|           | `:syntax on` / `:syntax off`   | Activar / desactivar resaltado |


### Flujo de Trabajo para Crear un Programa en Ensamblador ARM

Es importante recordar el flujo del ensamblador

```bash
hola.asm 
   ‚Üì (Ensamblador: as)
hola.o
   ‚Üì (Linker: ld)
hola  ‚Üí  Ejecutable
```

#### üßæ Paso 1: Crear o Editar el archivo fuente (Ensamblador)

Para empezar a escribir o editar tu archivo fuente en ensamblador, puedes hacerlo con un editor de texto como `vi` o cualquier otro editor disponible:

```bash
echo '.section .data\nmsg: .asciz "Hola, mundo!    "\n\n.section .text\n.global _start\n_start:\n    mov r0, #1\n    ldr r1, =msg\n    mov r2, #13\n    mov r7, #4\n    swi 0\n    mov r0, #0\n    mov r7, #1\n    swi 0' > /home/pi/hola.asm
```
Para abrirlo con un editor como vi:

```bash
vi hola.asm
```

Debe desplegar esto:

```paintext
.section .data
    msg: .asciz "Hola, mundo!  " // Mensaje 

.section .text
    .global _start

_start:
    mov r0, #1            // Establece el descriptor de archivo para stdout
    ldr r1, =msg          // Carga la direcci√≥n del mensaje en r1
    mov r2, #13           // Longitud del mensaje
    mov r7, #4            // N√∫mero de llamada al sistema para escribir
    swi 0                 // Llamada al sistema para escribir el mensaje

    mov r0, #0            // C√≥digo de salida
    mov r7, #1            // N√∫mero de llamada al sistema para salir
    swi 0                 // Llamada al sistema para salir del programa
```

#### Tabla de registros registros utilizados en **ARM32**

| Registro   | Nombre (32 bits) | Descripci√≥n                                                                                                                           |
| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **R0-R3**  | **r0 - r3**      | Registros de prop√≥sito general, usados para pasar par√°metros y devolver valores en las funciones.                                     |
| **R4-R7**  | **r4 - r7**      | Registros de prop√≥sito general. Usados como registros temporales en la mayor√≠a de las instrucciones.                                  |
| **R8-R12** | **r8 - r12**     | Registros de prop√≥sito general. Pueden ser utilizados por el compilador para almacenar valores temporales.                            |
| **R13**    | **SP**           | **Stack Pointer**. Apunta al tope de la pila en el sistema.                                                                           |
| **R14**    | **LR**           | **Link Register**. Guarda la direcci√≥n de retorno cuando se hace una llamada a funci√≥n (return address).                              |
| **R15**    | **PC**           | **Program Counter**. Contiene la direcci√≥n de la siguiente instrucci√≥n a ejecutar.                                                    |
| **CPSR**   | **CPSR**         | **Current Program Status Register**. Contiene el estado actual de los flags de la CPU (estado de las interrupciones, el modo, etc.).  |
| **SPSR**   | **SPSR**         | **Saved Program Status Register**. Almacena el estado del CPSR cuando se cambia de modo (por ejemplo, al entrar en una interrupci√≥n). |



#### üèó Paso 2: Ensamblado (Traducci√≥n a C√≥digo M√°quina)
El paso de ensamblado convierte el c√≥digo fuente en ensamblador a c√≥digo m√°quina. Usamos el ensamblador as para generar el archivo objeto:

```bash
as -o hola.o hola.asm
```

#### üîç Paso 3: Inspeccionar el Ensamblador desde el Objeto
Una vez generado el archivo objeto, se puedes inspeccionar con objdump para ver c√≥mo el c√≥digo ensamblador de manera comparativa con el c√≥didp realizado:

```bash
objdump -d /home/pi/hola.o
```

#### üîó Paso 4: Enlace (Linking)
El enlazado (linking) es el proceso donde el archivo objeto se convierte en un ejecutable final. Usamos el enlazador ld para combinar el archivo objeto con las bibliotecas y generar el ejecutable:

```bash
ld -o hola hola.o
```

#### üîí Paso 5: Otorgar permisos de ejecuci√≥n
Una vez que tienes el ejecutable, aseg√∫rate de otorgar permisos de ejecuci√≥n al archivo:

```bash
chmod +x hola
```

#### üöÄ Paso 6: Ejecuci√≥n
Finalmente, ejecuta el programa desde la termina.

```bash
./hola
```

<p align="center">
  <img src="images/hola_asm.png"  width="800"/>
</p>


### üìÄ Paso 6.2: C√≥digo a Depurar 

El siguiente script es una utilidad ligera escrita en Assembler que muestra informaci√≥n b√°sica del sistema al estilo de Neofetch pero de manera textual, sin acceder dinamicamente a las fuentes.
 
> **Nota:** **Neofetch** es una herramienta de l√≠nea de comandos escrita en **Bash** que muestra informaci√≥n del sistema de forma visual y personalizable.  
>
> Se puede instalar con:
>
> ```bash
> sudo apt install neofetch
> ```
> 
> Se puede ejecutar:
>
> ```bash
> neofetch
> ```


**El codigo por depurar es el siguente**:

En la terminal de  Qemu, se debe acceder al directorio `home/pi` de esta manera `cd home/pi`. Luego se debe ejecutar, lo siguiente (Este es el c√≥digo a depurar).  
```bash
echo '.section .data\ntitulo: .asciz "---------------------GENERAL INFORMATION------------------\n"\nso_info: .asciz "Sistema Operativo : Raspbian GNU/Linux 12 (bookworm)\n"\nkernel_info: .asciz "Versi√≥n del kernel: 4.19.50+\n"\narch_info: .asciz "Arquitectura      : armv6l\n"\n\n.section .text\n.global _start\n\n_start:\n\nprint_titulo:\n    mov r0, #1              // stdout\n    ldr r1, =titulo         // puntero al mensaje\n    mov r2, #60             // longitud\n    mov r7, #4              // syscall write\n    swi 0\n\nprint_so:\n    mov r0, #1\n    ldr r1, =so_info\n    mov r2, #54\n    mov r7, #4\n    swi 0\n\nprint_kernel:\n    mov r0, #1\n    ldr r1, =kernel_info\n    mov r2, #31\n    mov r7, #4\n    swi 0\n\nprint_arch:\n    mov r0, #1\n    ldr r1, =arch_info\n    mov r2, #28\n    mov r7, #4\n    swi 0\n\nexit_program:\n    mov r0, #0\n    mov r7, #1\n    swi 0' > /home/pi/info.asm

```
> A este punto se debe haber creado el script llamado `info.asm`, se puede verificar haciendo un  `ls` en la terminal.


### Paso 6.3: Depuraci√≥n
El script llamado `info.asm`, presenta una serie de errores, que deben ser corregidos para desplegar la informaci√≥n del sistema de manera correcta, esto se realizar√° mediante el uso del depurador GDB integra de manera nativa en Python. El objetivo del script es desplegar lo siguiente: 

<p align="center">
  <img src="images/info_asm.png"  width="800"/>
</p>

### üõ† Comandos √∫tiles dentro de gdb

| Comando                           | Descripci√≥n                                                                                        |
| --------------------------------- | -------------------------------------------------------------------------------------------------- |
| `gdb ./programa`                  | Inicia GDB con el programa especificado.                                                           |
| `run` (o `r`)                     | Inicia la ejecuci√≥n del programa.                                                                  |
| `break <l√≠nea>` (o `b <l√≠nea>`)   | Coloca un punto de interrupci√≥n en una l√≠nea espec√≠fica del c√≥digo. Ejemplo: `b 10` para l√≠nea 10. |
| `break <funci√≥n>`                 | Coloca un punto de interrupci√≥n en una funci√≥n espec√≠fica.                                         |
| `continue` (o `c`)                | Contin√∫a la ejecuci√≥n hasta el siguiente punto de interrupci√≥n.                                    |
| `next` (o `n`)                    | Avanza al siguiente paso de c√≥digo, pero sin entrar en las funciones.                              |
| `step` (o `s`)                    | Avanza al siguiente paso de c√≥digo, entrando en las funciones si las hay.                          |
| `finish`                          | Completa la ejecuci√≥n de la funci√≥n actual y regresa al lugar donde fue llamada.                   |
| `print <variable>`                | Muestra el valor de una variable. Ejemplo: `print x`.                                              |
| `info locals`                     | Muestra las variables locales de la funci√≥n actual.                                                |
| `info args`                       | Muestra los argumentos de la funci√≥n actual.                                                       |
| `info break`                      | Muestra informaci√≥n sobre los puntos de interrupci√≥n actuales.                                     |
| `delete <n√∫mero>`                 | Elimina el punto de interrupci√≥n con el n√∫mero especificado.                                       |
| `list`                            | Muestra las l√≠neas de c√≥digo fuente cercanas al punto donde est√° el programa.                      |
| `backtrace` (o `bt`)              | Muestra la pila de llamadas (stack trace).                                                         |
| `quit` (o `q`)                    | Sale de GDB.                                                                                       |
| `watch <variable>`                | Coloca un "watchpoint" para que GDB detenga la ejecuci√≥n cuando el valor de una variable cambie.   |
| `info registers`                  | Muestra el contenido de todos los registros del procesador.                                        |
| `disassemble`                     | Muestra el c√≥digo ensamblador de la funci√≥n actual o de la regi√≥n de memoria especificada.         |
| `set variable <variable>=<valor>` | Cambia el valor de una variable en tiempo de ejecuci√≥n.                                            |
| `list <funci√≥n>`                  | Muestra el c√≥digo fuente de una funci√≥n espec√≠fica.                                                |
| `x/<n> <direcci√≥n>`               | Muestra el contenido de memoria en formato hexadecimal o ASCII. Ejemplo: `x/10x $esp`.             |
| `start`                           | Inicia la ejecuci√≥n del programa y se detiene en la primera l√≠nea de la funci√≥n `main`.            |


---
Para ensamblar el codigo con las bandera de depuraci√≥n, se deben aplicar las siguientes banderas:

```bash
as -g -o info.o /home/pi/info.asm
```

```bash
ld -g -o info info.o
```

```bash
gdb ./info
```

Una vez dentro de GDB, lo primero siempre es definir los breakpoints dados por las etiquetas de la siguiente manera:

```bash
(gdb) break _start
```
```bash
(gdb) break print_titulo
```
```bash
(gdb) break print_os
```
```bash
(gdb) break print_kernel
```
```bash
(gdb) break print_arch
```

5. Depuraci√≥n interactiva
Puedes ir revisando los registros y la memoria, o incluso ir paso por paso, con comandos como:

- info registers: Ver los valores actuales de los registros.
```bash
 info registers
```

- x/10xw $sp: Ver el contenido de un registro en hexadecimal.
```bash
x/c 0x<reg>
```
- step o next para avanzar entre las instrucciones.
```bash
step
```
---
- Reto a: ERROR 1 (¬øEl salto de linea es as√≠?)
 
- Reto b: ERROR 2 (¬øEl salto de linea es as√≠?)

- Reto c: ERROR 3 (¬øEl salto de linea es as√≠?)

- Reto d: ERROR 4 (¬øEl salto de linea es as√≠?)


---

## 5. Referencias

[1] QEMU Project. ‚ÄúQEMU: A generic and open source machine emulator and virtualizer,‚Äù *GitLab repository*. [Online]. Available: [https://gitlab.com/qemu-project/qemu](https://gitlab.com/qemu-project/qemu)

[2] GNU Project. ‚ÄúGDB: The GNU Debugger,‚Äù *Sourceware repository*. [Online]. Available: [https://sourceware.org/git/binutils-gdb.git](https://sourceware.org/git/binutils-gdb.git)

[3] Python Software Foundation. ‚Äúpdb ‚Äî The Python Debugger,‚Äù *Python 3 Documentation*. [Online]. Available: [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)

[4] Python Software Foundation. ‚Äúpdb.py ‚Äî Source code,‚Äù *CPython GitHub Repository*. [Online]. Available: [https://github.com/python/cpython/blob/main/Lib/pdb.py](https://github.com/python/cpython/blob/main/Lib/pdb.py)
